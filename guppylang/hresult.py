from __future__ import annotations
from collections import Counter, defaultdict
from typing import NamedTuple, TYPE_CHECKING

from dataclasses import dataclass, field
import re

if TYPE_CHECKING:
    from pytket.backends.backendresult import BackendResult
#: Primitive data types that can be returned by a result
DataPrimitive = int | float | bool
#: Data value that can be returned by a result: a primitive or a list of primitives
DataValue = DataPrimitive | list[DataPrimitive]
TaggedResult = tuple[str, DataValue]
# Pattern to match register index in tag, e.g. "reg[0]"
REG_INDEX_PATTERN = re.compile(r"^([a-z][\w_]*)\[(\d+)\]$")


class ResultEntry(NamedTuple):
    """A single result entry, generated by a `result` call."""

    #: The tag of the result
    tag: str
    #: The result value
    data: DataValue


@dataclass
class Results:
    """Results from a single shot execution."""

    entries: list[ResultEntry] = field(default_factory=list)

    def __init__(self, entries: list[tuple[str, DataValue]] | None = None):
        self.entries = [ResultEntry(*entry) for entry in entries] if entries else []

    def append(self, tag: str, data: DataValue):
        self.entries.append(ResultEntry(tag, data))

    def as_dict(self) -> dict[str, DataValue]:
        """Convert results to a dictionary.

        For duplicate tags, the last value is used.

        Returns:
            dict: A dictionary where the keys are the tags and the
            values are the data.

        Example:
            >>> results = Results()
            >>> results.append("tag1", 1)
            >>> results.append("tag2", 2)
            >>> results.append("tag2", 3)
            >>> results.as_dict()
            {"tag1": 1, "tag2": 3}
        """
        return {entry.tag: entry.data for entry in self.entries}

    def to_register_bits(self) -> dict[str, list[bool]]:
        """Convert results to a dictionary of register bit values."""
        reg_bits: dict[str, list[bool]] = {}

        res_dict = self.as_dict()
        for tag, data in res_dict.items():
            match = re.match(REG_INDEX_PATTERN, tag)
            if match is not None:
                reg_name, reg_index_str = match.groups()
                reg_index = int(reg_index_str)

                if reg_name not in reg_bits:
                    # Initialize register counts to False
                    reg_bits[reg_name] = [False] * (int(reg_index) + 1)
                bitlst = reg_bits[reg_name]
                if reg_index >= len(bitlst):
                    # Extend register counts with False
                    bitlst += [False] * (int(reg_index) - len(bitlst) + 1)

                bitlst[reg_index] = _cast_primitive_bool(data)
                continue
            match data:
                case list(vs):
                    reg_bits[tag] = [_cast_primitive_bool(v) for v in vs]
                case _:
                    reg_bits[tag] = [_cast_primitive_bool(data)]

        return reg_bits

    def to_register_bitstrings(self) -> dict[str, str]:
        """Convert results to a dictionary of register bitstrings."""
        reg_bits = self.to_register_bits()
        return {reg: bools_to_bitstring(bits) for reg, bits in reg_bits.items()}


def bools_to_bitstring(bools: list[bool]) -> str:
    return "".join("1" if b else "0" for b in bools)


def _cast_primitive_bool(data: DataValue) -> bool:
    match data:
        case bool(v):
            return v
        case int(1):
            return True
        case int(0):
            return False
        case _:
            raise ValueError(f"Expected bool data for register value found {data}")


@dataclass
class ShotResults:
    """Results accumulated over multiple shots."""

    shots: list[Results] = field(default_factory=list)

    def register_counts(
        self, strict_names: bool = False, strict_lengths: bool = False
    ) -> dict[str, Counter[str]]:
        """Convert results to a dictionary of register counts.

        Returns:
            dict: A dictionary where the keys are the register names
            and the values are the counts of the register bitstrings.
        """
        return {
            reg: Counter(bitstrs)
            for reg, bitstrs in self.register_bitstrings(
                strict_lengths=strict_lengths, strict_names=strict_names
            ).items()
        }

    def register_bitstrings(
        self, strict_names: bool = False, strict_lengths: bool = False
    ) -> dict[str, list[str]]:
        """Convert results to a dictionary from register name to list of bitstrings over
        the shots.

        Args:
            strict_names: Whether to enforce that all shots have the same
                registers.
            strict_lengths: Whether to enforce that all register bitstrings have
                the same length.

        """

        shot_dct = defaultdict(list)
        for shot in self.shots:
            bitstrs = shot.to_register_bitstrings()
            for reg, bitstr in bitstrs.items():
                if (
                    strict_lengths
                    and reg in shot_dct
                    and len(shot_dct[reg][0]) != len(bitstr)
                ):
                    raise ValueError(
                        "All register bitstrings must have the same length."
                    )
                shot_dct[reg].append(bitstr)
            if strict_names and not bitstrs.keys() == shot_dct.keys():
                raise ValueError("All shots must have the same registers.")
        return shot_dct

    def to_pytket(self) -> BackendResult:
        """Convert results to a pytket BackendResult.

        Returns:
            BackendResult: A BackendResult object with the shots.

        Raises:
            ImportError: If pytket is not installed.
            ValueError: If a register's bitstrings have different lengths or not all
            registers are present in all shots.
        """
        try:
            from pytket.backends.backendresult import BackendResult
            from pytket.utils.outcomearray import OutcomeArray
            from pytket._tket.unit_id import Bit
        except ImportError as e:
            raise ImportError(
                "Pytket is an optional dependency, install with the `pytket` extra"
            ) from e
        counts = self.register_bitstrings(strict_lengths=True, strict_names=True)
        reg_sizes: dict[str, int] = {
            reg: len(next(iter(counts[reg]), "")) for reg in counts
        }
        registers = list(counts.keys())
        bits = [Bit(reg, i) for reg in registers for i in range(reg_sizes[reg])]
        int_shots = [
            [ord(bitval) - 48 for reg in registers for bitval in counts[reg][i]]
            for i in range(len(self.shots))
        ]
        return BackendResult(shots=OutcomeArray.from_readouts(int_shots), c_bits=bits)
